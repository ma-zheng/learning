# Rpc(Remote Process Call)

Rpc 远端过程调用，看了网上的很多说法，记住了一句话，像调用本地方法一样调用远程服务。

1. 理解

   远端过程调用，终究是一个调用。可以类比本地方法调用的方式来理解它，所不同的是，它的执行端是在远端。

   1. 以面向对象的理解为例，一个调用，首先要有一个对象，其次是对这个对象进行方法调用。对于本地调用来说，对象内本身包含了具体方法的执行逻辑，
可以理解为对象的'实体'，而远端调用，虽然也需要在本地有一个对象，只不过这个对象并不包含具体方法实现，而是将调用信息传递给远端的'实体'对象。
暂且将本地不包含具体逻辑的对象成为'代理'对象。之后由远端的实体对象实际执行，再将结果返回给本地的代理对象。
   2. 由于这里调用方和被调用方不在同一个进程(JVM)中，所以这里类似于本地方法调用的传参，就变成了网络传输对象。在同一个JVM中，参数的传递是以
内存地址的方式传递给被调用方，地址所指向的数据均存放于heap中。在本地传输的过程中，由于调用方和被调用方均处于同一个JVM中，所以heap
是共享的，直接通过内存寻址就可以找到对应的数据，用于计算。同时可以将结果存放于heap中，将结果的地址返回给调用方，调用方就可以在heap找到对应
的结果。而远端调用由于调用方和被调用方不在同一个JVM中，内存是不共享的，所以无法直接通过内存地址来直接寻址。那么就需要将一个进程中的对象
传递到另一个进程中。大致流程为从调用方的内存中将对象序列化为可传输的二进制流，通过网络协议进行传输此二进制流，在被调用方处接收二进制流，并将
该流反序列化为对象。这里就涉及到了序列化/反序列化格式和网络传输协议。

2. 代码实践

   光说不练假把式。作为程序员，深感只读代码是不行的。为了更好地理解或掌握，必须要进行实际编写。这里就以简单的算数方法来进行rpc的学习。本例子
中，使用了socket进行数据的传输，使用java自身的序列化反序列化机制。
   "像本地一样调用"是依赖于`Proxy#newProxyInstance()`方法实现的。在Java中，实例化一个对象通常可以通过`new`关键字来进行，或者通过
反射`Class#newInstance()`生成。在RPC中，通常是通过`Proxy#newProxyInstance()`来实例化一个接口，这个接口定义了远端的服务。之后通过这个
接口'实例'就可以像本地方法一样调用远端服务服务的方法。而`Proxy#newProxyInstance()`这个方法有个参数是InvocationHandler，这个handler里
的逻辑就是控制远程调用的逻辑。在Flink的RPC中，通过invacationHander控制了哪些方法是本地调用，哪些方法是远端调用。
